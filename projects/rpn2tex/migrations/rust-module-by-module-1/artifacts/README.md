# Phase 0 Artifacts - I/O Contract Generation

This directory contains the complete I/O contract and execution documentation for the Python rpn2tex reference implementation.

## Files

### Primary Contract Document
**`PHASE_0_IO_CONTRACT.md`** (170 lines)
- Complete specification of all 21 test cases
- Expected outputs with detailed notes
- Output format specifications
- Error case documentation
- Guidance for Rust migration
- **Use this file:** For detailed reference during Rust implementation

### Quick Reference
**`IO_CONTRACT_SUMMARY.csv`** (22 lines)
- Machine-readable format
- All test cases in 3 columns: Test #, Input, Output/Error
- **Use this file:** For automated comparison in test scripts

### Execution Documentation
**`PHASE_0_EXECUTION_LOG.md`** (188 lines)
- Complete execution methodology
- Environment details
- Test results summary with statistics
- Error analysis
- Key observations for Rust migration
- Validation checklist
- **Use this file:** To understand how outputs were generated

## Quick Statistics

| Metric | Value |
|--------|-------|
| Total Test Cases | 21 |
| Successful Cases | 18 |
| Error Cases | 3 |
| Success Rate | 85.7% |
| Unsupported Feature | Exponentiation (^) |

## Test Coverage

### Basic Operations (6 tests)
- Addition, subtraction, multiplication, division
- Floating point support
- All basic operations work correctly

### Operator Precedence (8 tests)
- Multiplication/division higher than addition/subtraction
- Left-to-right associativity
- Automatic parenthesis insertion based on precedence
- All precedence rules correctly implemented

### Complex Expressions (4 tests)
- Chained operations with mixed operators
- Multiple precedence levels
- Complex grouping with multiple operands
- All complex cases handled correctly

### Error Cases (3 tests)
- Exponentiation operator (^) rejected with proper error messages
- Error location (line/column) correctly reported
- Error messages consistently formatted

## Error Case Details

The Python implementation rejects the exponentiation operator:

```
Input: "2 3 ^"
Error: Line 1, column 5: Unexpected character '^'
```

This occurs in the lexer phase before parsing. The Rust implementation must decide whether to:
1. Also reject `^` to maintain behavioral equivalence
2. Implement `^` support as an enhancement

## Usage in Rust Migration

### Phase 1 - Feature Specification
Use `PHASE_0_IO_CONTRACT.md` to extract detailed specifications for:
- Lexer token definitions and error handling
- Parser grammar and precedence rules
- LaTeX generator output formatting

### Phase 2 - Implementation
Reference `IO_CONTRACT_SUMMARY.csv` in test scripts to validate outputs:
```bash
# Example test for case 1
cargo run -- "5 3 +" | diff - <(echo '$5 + 3$')
```

### Phase 3 - Validation
Use `PHASE_0_EXECUTION_LOG.md` to understand edge cases and design decisions:
- Floating point number handling
- Parenthesis generation algorithm
- Error message format requirements

## Output Format Specification

All successful LaTeX outputs follow this pattern:
- Wrapped in `$...$` (math mode delimiters)
- Operators: `+`, `-`, `\times`, `\div`
- Spacing: ` operator ` (spaces around operators)
- Parentheses: `( expression )` with internal spacing
- Numbers: preserved exactly (integers and decimals)

## Important Notes

1. **Byte-for-Byte Equivalence:** The Rust implementation MUST produce identical output including spacing and LaTeX commands.

2. **Error Messages:** Must match exactly:
   - Format: `Line {line}, column {column}: {message}`
   - Character positions must be accurate

3. **Floating Point:** Both integer and decimal numbers must be supported and output exactly as received.

4. **Precedence:** Critical for correctness:
   - Multiplication and division have higher precedence than addition and subtraction
   - Operations of the same precedence associate left-to-right
   - Parentheses are inserted when necessary

## Generated By

These artifacts were generated by the I/O contract generator on 2025-12-29.

The Python implementation was executed directly using the pipeline:
```
Input → Lexer.tokenize() → Parser.parse() → LaTeXGenerator.generate() → Output
```

Each of the 21 test inputs was processed independently, and outputs were captured exactly as produced.
