# RPN2TEX Python to Java Migration Specification

## Document Overview

This specification provides a module-by-module analysis of the Python rpn2tex codebase and detailed guidance for migrating each module to Java. The specification includes the I/O contract from Phase 0, which serves as the behavioral validation benchmark for the Java implementation.

---

## I/O Contract

### Test Cases

Generated by running the Python source implementation on 21 test inputs.

| Input | Expected Output | Notes |
|-------|-----------------|-------|
| `5 3 +` | `$5 + 3$` | Basic addition |
| `5 3 -` | `$5 - 3$` | Basic subtraction |
| `4 7 *` | `$4 \times 7$` | Basic multiplication |
| `10 2 /` | `$10 \div 2$` | Basic division |
| `2 3 ^` | ERROR: Unexpected character '^' | Exponentiation not supported |
| `5 3 + 2 *` | `$( 5 + 3 ) \times 2$` | Operator precedence with parentheses |
| `5 3 * 2 +` | `$5 \times 3 + 2$` | Operator precedence (multiplication before addition) |
| `10 2 / 5 *` | `$10 \div 2 \times 5$` | Left-associative operations |
| `5 3 - 2 -` | `$5 - 3 - 2$` | Multiple subtractions |
| `100 10 / 5 / 2 /` | `$100 \div 10 \div 5 \div 2$` | Multiple divisions |
| `1 2 + 3 + 4 +` | `$1 + 2 + 3 + 4$` | Multiple additions |
| `2 3 4 * +` | `$2 + 3 \times 4$` | Multiplication takes precedence over addition |
| `2 3 + 4 *` | `$( 2 + 3 ) \times 4$` | Parentheses around addition before multiplication |
| `2 3 4 + *` | `$2 \times ( 3 + 4 )$` | Parentheses around addition as second operand |
| `2 3 * 4 +` | `$2 \times 3 + 4$` | Multiplication before addition (no parentheses needed) |
| `2 3 ^ 4 *` | ERROR: Unexpected character '^' | Exponentiation not supported |
| `2 3 4 ^ ^` | ERROR: Unexpected character '^' | Exponentiation not supported |
| `3.14 2 *` | `$3.14 \times 2$` | Floating-point numbers |
| `1.5 0.5 +` | `$1.5 + 0.5$` | Floating-point addition |
| `1 2 + 3 4 + *` | `$( 1 + 2 ) \times ( 3 + 4 )$` | Multiple parenthesized expressions |
| `10 2 / 3 + 4 *` | `$( 10 \div 2 + 3 ) \times 4$` | Complex expression with mixed operators |

### Error Cases

The Python source implementation does not support the exponentiation operator (`^`). Attempting to use it results in a lexer error.

#### Error Format

Error messages follow this format:
```
Error: Unexpected character '^'

<line> | <expression>
  |     <pointer>
```

#### Inputs Producing Errors

1. **`2 3 ^`** - Exponentiation operator not recognized
   - Error: `Error: Unexpected character '^'`

2. **`2 3 ^ 4 *`** - Exponentiation operator not recognized
   - Error: `Error: Unexpected character '^'`

3. **`2 3 4 ^ ^`** - Exponentiation operator not recognized
   - Error: `Error: Unexpected character '^'`

### Supported Operations

The Python source implementation supports:

- **Addition (`+`)**: Produces `\+` in LaTeX
- **Subtraction (`-`)**: Produces `-` in LaTeX
- **Multiplication (`*`)**: Produces `\times` in LaTeX
- **Division (`/`)**: Produces `\div` in LaTeX

### Supported Operands

- **Integers**: e.g., `5`, `42`, `100`
- **Floating-point numbers**: e.g., `3.14`, `1.5`, `0.5`

### LaTeX Output Format

All outputs are wrapped in LaTeX math delimiters (`$...$`):
- Binary operations are formatted with proper spacing
- Operator precedence is respected
- Parentheses are added where necessary to preserve evaluation order
- Spaces are included around operators for readability

### Notes for Migration

1. The current Python implementation does not support exponentiation (`^`)
2. Error messages are formatted with context showing the line and column of the error
3. All LaTeX output includes the dollar sign delimiters
4. Floating-point numbers are preserved as-is in the output
5. The implementation uses RPN (Reverse Polish Notation) as input format

---

## Module-by-Module Analysis

### Module 1: tokens.py

**File**: `/Users/jfreeman/Coding/rpn2tex-rust-migration/projects/rpn2tex/source/tokens.py`

#### Public API

**Classes:**
- `TokenType(Enum)`: Enumeration of token types
  - `NUMBER`: Numeric literals (integers and decimals)
  - `PLUS`: Addition operator (+)
  - `MINUS`: Subtraction operator (-)
  - `MULT`: Multiplication operator (*)
  - `DIV`: Division operator (/)
  - `EOF`: End of file marker

- `Token(dataclass)`: Immutable token representation
  - Attributes:
    - `type: TokenType`: The token's type
    - `value: str`: The string value of the token
    - `line: int`: Line number (1-based)
    - `column: int`: Column number (1-based)
  - Methods:
    - `__repr__() -> str`: String representation for debugging

#### Dependencies
- Internal: None
- External: `dataclasses`, `enum`

#### Java Migration Notes

**Type Mappings:**
- `TokenType(Enum)` → Java `enum TokenType { NUMBER, PLUS, MINUS, MULT, DIV, EOF }`
- `Token(dataclass)` → Java `final class Token` with immutable fields
- `@dataclass(frozen=True)` → Java immutable class with `final` fields and custom `equals()`, `hashCode()`, `toString()`
- `Enum.auto()` → Java enum constants (ordinals implicit)

**Pattern Changes:**
- Python `__repr__()` → Java `toString()` returning formatted string like `"Token(NUMBER, '42', 1:5)"`
- Python dataclass equality → Java implementation of `equals(Object)` and `hashCode()` for immutable value objects
- Python type annotations → Java explicit type declarations

**Special Handling:**
- Token immutability: Use `final` keyword on all fields and class
- String formatting: Preserve Python's `__repr__` format in `toString()` for compatibility with test expectations
- Position tracking: Ensure 1-based line/column numbers are maintained

#### Key Implementation Details

The Token module defines two fundamental data structures:

1. **TokenType Enum**: Simple enumeration with 6 distinct values representing lexical elements
2. **Token Class**: Immutable value object capturing a token's type, text value, and source position

These are fundamental building blocks used throughout the lexer, parser, and error handling. The frozen dataclass pattern in Python ensures tokens cannot be modified after creation—critical for maintaining integrity through the parsing pipeline.

---

### Module 2: ast_nodes.py

**File**: `/Users/jfreeman/Coding/rpn2tex-rust-migration/projects/rpn2tex/source/ast_nodes.py`

#### Public API

**Classes:**
- `ASTNode(dataclass)`: Base class for all AST nodes
  - Attributes:
    - `line: int`: Line number (1-based)
    - `column: int`: Column number (1-based)

- `Number(ASTNode)`: Numeric literal node
  - Attributes:
    - `line: int`: Line number
    - `column: int`: Column number
    - `value: str`: String representation of the number

- `BinaryOp(ASTNode)`: Binary operation node
  - Attributes:
    - `line: int`: Line number
    - `column: int`: Column number
    - `operator: str`: Operator string ("+", "-", "*", "/")
    - `left: Expr`: Left operand expression
    - `right: Expr`: Right operand expression

**Type Aliases:**
- `Expr = Number | BinaryOp`: Union type representing all expression types

#### Dependencies
- Internal: None
- External: `dataclasses`

#### Java Migration Notes

**Type Mappings:**
- `ASTNode` (abstract base) → Java `abstract class ASTNode` with abstract position tracking
- `Number` → Java `final class Number extends ASTNode`
- `BinaryOp` → Java `final class BinaryOp extends ASTNode`
- `Expr` (union type) → Java interface `interface Expr` with Number and BinaryOp as implementations OR sealed abstract class
- `@dataclass(frozen=True)` → Java immutable classes with `final` fields

**Pattern Changes:**
- Python union type `Number | BinaryOp` → Java interface hierarchy:
  ```java
  sealed interface Expr permits Number, BinaryOp {}
  final class Number implements Expr { ... }
  final class BinaryOp implements Expr { ... }
  ```
- Or alternative using abstract class pattern:
  ```java
  abstract class Expr { line, column }
  final class Number extends Expr { value }
  final class BinaryOp extends Expr { operator, left, right }
  ```

**Special Handling:**
- Immutability: All fields must be `final`, constructors must fully initialize
- Recursive type references: Ensure forward compatibility for `left: Expr` and `right: Expr` in BinaryOp
- Value semantics: Implement `equals()` and `hashCode()` based on all fields

#### Key Implementation Details

The AST module defines the tree structure representation of parsed expressions:

1. **ASTNode Base Class**: Tracks source position for error reporting (line, column)
2. **Number Node**: Represents numeric literals; stores value as string
3. **BinaryOp Node**: Represents binary operations with left and right child expressions

The key invariant is that the AST is immutable and recursive—BinaryOp nodes contain references to child Expr nodes, building tree structures that represent evaluation order. Position information flows through the tree for precise error reporting.

The expression type (Expr) is abstract and can be either a Number or BinaryOp, enabling type-safe traversal during LaTeX generation.

---

### Module 3: errors.py

**File**: `/Users/jfreeman/Coding/rpn2tex-rust-migration/projects/rpn2tex/source/errors.py`

#### Public API

**Classes:**
- `ErrorFormatter`: Formats parse errors with source context
  - Attributes:
    - `source: str`: The complete source text
    - `lines: list[str]`: Source split into lines
  - Methods:
    - `__init__(source: str) -> None`: Initialize with source text
    - `format_error(message: str, line: int, column: int, *, context_lines: int = 1) -> str`: Format error with context
    - `_get_context(line: int, column: int, context_lines: int) -> str`: Extract context around error

#### Dependencies
- Internal: None
- External: None (pure Python standard library)

#### Java Migration Notes

**Type Mappings:**
- `ErrorFormatter` → Java `class ErrorFormatter`
- `self` → Java `this` (implicit in methods)
- `list[str]` → Java `List<String>`
- Default parameters (`context_lines: int = 1`) → Java method overloading or explicit parameter in single method

**Pattern Changes:**
- Python string methods (`splitlines()`) → Java `String.split("\\n")` or `String.lines()`
- Python f-strings → Java `String.format()` or `StringBuilder`
- Python slicing (`self.lines[idx]`) → Java list indexing with bounds checks
- Python `range()` → Java `for` loop or stream

**Special Handling:**
- Line and column are 1-based (not 0-based): maintain this invariant in Java
- Context extraction logic must preserve exact positioning of caret character
- String padding for line numbers must be right-aligned to handle variable-width line numbers

#### Key Implementation Details

The ErrorFormatter class formats compiler-style error messages with source context:

1. **Initialization**: Splits source into lines for easy access
2. **format_error()**: Creates formatted error message with context
3. **_get_context()**: Extracts and formats source context with line numbers and caret pointer

The formatter produces output like:
```
Error: Unexpected character '^'

1 | 5 3 ^
    ^
```

This requires careful string manipulation to align line numbers and position the caret correctly at the exact column of the error (1-based indexing).

---

### Module 4: lexer.py

**File**: `/Users/jfreeman/Coding/rpn2tex-rust-migration/projects/rpn2tex/source/lexer.py`

#### Public API

**Classes:**
- `LexerError(Exception)`: Exception raised by lexer
  - Attributes:
    - `message: str`: Description of error
    - `line: int`: Line number (1-based)
    - `column: int`: Column number (1-based)
  - Methods:
    - `__init__(message: str, line: int, column: int) -> None`

- `Lexer`: Tokenizes RPN input text
  - Attributes:
    - `text: str`: Input text to tokenize
    - `pos: int`: Current position (0-based)
    - `line: int`: Current line number (1-based)
    - `column: int`: Current column number (1-based)
  - Methods:
    - `__init__(text: str) -> None`: Initialize lexer
    - `tokenize() -> list[Token]`: Tokenize entire input (returns tokens with EOF at end)
    - `_at_end() -> bool`: Check if at end of input
    - `_peek() -> str`: Look at current character without consuming
    - `_advance() -> str`: Consume and return current character
    - `_skip_whitespace() -> None`: Skip over whitespace
    - `_scan_token() -> Token`: Scan next token
    - `_scan_number(prefix: str, start_line: int, start_column: int) -> Token`: Scan numeric literal

#### Dependencies
- Internal: `tokens` (Token, TokenType)
- External: None (standard library only)

#### Java Migration Notes

**Type Mappings:**
- `LexerError(Exception)` → Java `class LexerError extends Exception`
- `Lexer` → Java `class Lexer`
- `str` → Java `String`
- `int` → Java `int`
- `list[Token]` → Java `List<Token>`
- Exception attributes → Java fields with getters

**Pattern Changes:**
- Python exception with attributes → Java exception class with fields and custom constructor
- Python `len()` function → Java `String.length()`
- Python string indexing (`text[pos]`) → Java `String.charAt(index)`
- Python `char.isdigit()` → Java `Character.isDigit(char)`
- Python error string → Java exception message passed to super

**Special Handling:**
- Position tracking (line/column) must be synchronized with character advancement
- Newline handling: When advancing past `\n`, increment line and reset column to 1
- Negative number parsing: Look ahead after `-` to determine if it's a negative number or subtraction operator
- Character peeking: Return empty string when at end (must handle gracefully)

#### Key Implementation Details

The Lexer implements character-by-character scanning with position tracking:

1. **State Management**: Tracks current position, line, and column through the input
2. **Whitespace Skipping**: Consumes spaces, tabs, newlines, carriage returns
3. **Token Scanning**: Recognizes operators (+, -, *, /) and numbers (integers and decimals)
4. **Negative Number Detection**: Distinguishes between `-` as subtraction vs. prefix for negative numbers
5. **Error Reporting**: Captures position information for error reporting via LexerError

The tokenize() method orchestrates the scanning process and appends an EOF token at the end. All position information is 1-based for user-friendly error messages.

**Critical Implementation Detail**: The negative number handling checks if a digit immediately follows `-` without whitespace. This requires looking ahead after advancing past the minus sign.

---

### Module 5: parser.py

**File**: `/Users/jfreeman/Coding/rpn2tex-rust-migration/projects/rpn2tex/source/parser.py`

#### Public API

**Classes:**
- `ParserError(Exception)`: Exception raised by parser
  - Attributes:
    - `message: str`: Description of error
    - `token: Token`: Token where error occurred
  - Methods:
    - `__init__(message: str, token: Token) -> None`

- `Parser`: Stack-based RPN parser
  - Attributes:
    - `tokens: list[Token]`: Tokens to parse
    - `pos: int`: Current position in token list (0-based)
  - Methods:
    - `__init__(tokens: list[Token]) -> None`: Initialize parser
    - `parse() -> Expr`: Parse tokens into AST
    - `_current() -> Token`: Get current token
    - `_at_end() -> bool`: Check if at EOF token
    - `_advance() -> Token`: Consume and return current token

#### Dependencies
- Internal: `ast_nodes` (BinaryOp, Expr, Number), `tokens` (Token, TokenType)
- External: None (standard library only)

#### Java Migration Notes

**Type Mappings:**
- `ParserError(Exception)` → Java `class ParserError extends Exception`
- `Parser` → Java `class Parser`
- `Expr` → Java interface or abstract class (from ast_nodes migration)
- `list[Token]` → Java `List<Token>` or `Token[]`
- `list[Expr]` (stack) → Java `Deque<Expr>` or `Stack<Expr>`

**Pattern Changes:**
- Python list as stack → Java `java.util.Deque<Expr>` with `push()`, `pop()`, `size()`
- Python `len(stack)` → Java `stack.size()`
- Python list `append()` → Java `deque.push()` or `stack.push()`
- Python list `pop()` → Java `deque.pop()` or `stack.pop()`
- Python dictionary/mapping → Java `Map<TokenType, String>` for op_map

**Special Handling:**
- Stack validation: Check that exactly 1 element remains at end
- Token consumption: Manage position pointer carefully when advancing through EOF
- Error messages: Include token position information (line, column) in ParserError

#### Key Implementation Details

The Parser implements RPN (Reverse Polish Notation) parsing using a stack-based algorithm:

1. **Stack Processing**: Maintains a stack of Expr nodes
2. **Number Handling**: When a NUMBER token is encountered, create a Number node and push to stack
3. **Operator Handling**: When an operator token is encountered:
   - Pop two operands (right, then left)
   - Create BinaryOp node with operator and operands
   - Push result back to stack
4. **Validation**: At EOF, exactly one element should remain on stack (the root expression)

**Error Cases Handled:**
- Not enough operands for operator
- Extra operands remaining (missing operators)
- Empty expression

**RPN Algorithm Example:**
- Input: `5 3 + 2 *`
- `5`: push Number(5) → stack = [5]
- `3`: push Number(3) → stack = [5, 3]
- `+`: pop 3, pop 5, push BinaryOp(+, 5, 3) → stack = [5+3]
- `2`: push Number(2) → stack = [5+3, 2]
- `*`: pop 2, pop 5+3, push BinaryOp(*, 5+3, 2) → stack = [(5+3)*2]
- Result: BinaryOp(*, BinaryOp(+, 5, 3), 2)

---

### Module 6: latex_gen.py

**File**: `/Users/jfreeman/Coding/rpn2tex-rust-migration/projects/rpn2tex/source/latex_gen.py`

#### Public API

**Classes:**
- `LaTeXGenerator`: Converts AST to LaTeX source
  - Class Attributes:
    - `BINARY_OPS: dict[str, str]`: Operator to LaTeX command mapping
      - `"+"` → `"+"`
      - `"-"` → `"-"`
      - `"*"` → `r"\times"`
      - `"/"` → `r"\div"`
    - `PRECEDENCE: dict[str, int]`: Operator precedence (higher = tighter binding)
      - `"+"` → `1`, `"-"` → `1`
      - `"*"` → `2`, `"/"` → `2`
  - Methods:
    - `__init__() -> None`: Initialize generator
    - `generate(ast: Expr) -> str`: Generate LaTeX from AST
    - `_visit(node: Expr) -> str`: Visitor dispatcher (singledispatchmethod)
    - `_visit_number(node: Number) -> str`: Generate LaTeX for Number
    - `_visit_binary_op(node: BinaryOp) -> str`: Generate LaTeX for BinaryOp
    - `_needs_parens(child: Expr, parent_precedence: int, *, is_right: bool) -> bool`: Determine if parentheses needed

#### Dependencies
- Internal: `ast_nodes` (BinaryOp, Expr, Number)
- External: `functools` (singledispatchmethod)

#### Java Migration Notes

**Type Mappings:**
- `LaTeXGenerator` → Java `class LaTeXGenerator`
- `@singledispatchmethod` → Java polymorphism (method overloading or type-switch)
- `ClassVar[dict[str, str]]` → Java `static final Map<String, String>`
- `ClassVar[dict[str, int]]` → Java `static final Map<String, Integer>`
- `dict[str, str]` → Java `Map<String, String>`

**Pattern Changes:**
- Python `@singledispatchmethod` decorator → Java method overloading:
  ```java
  private String visit(Expr node) throws RuntimeException { ... }
  private String visit(Number node) { ... }
  private String visit(BinaryOp node) { ... }
  ```
  Or use visitor pattern with explicit type checking:
  ```java
  if (node instanceof Number) { ... }
  else if (node instanceof BinaryOp) { ... }
  ```
- Python f-strings → Java `String.format()` or `+` concatenation
- Python `isinstance()` → Java `instanceof` operator
- Raw string literals (`r"\times"`) → Java raw strings or escaped backslashes (`"\\times"`)

**Special Handling:**
- Operator precedence logic for parenthesization:
  - Lower precedence child always needs parens
  - Equal precedence on right side needs parens for left-associative operators (- and /)
- LaTeX command escaping: Backslashes in LaTeX commands must be properly escaped
- Output wrapping: Result wrapped in `$...$` math mode delimiters

#### Key Implementation Details

The LaTeXGenerator converts the AST to infix notation with proper parenthesization:

1. **Visitor Pattern**: Uses method dispatch to handle different node types (Number vs BinaryOp)
2. **Operator Precedence**:
   - Addition/subtraction: precedence 1
   - Multiplication/division: precedence 2
3. **Parenthesization Logic**:
   - Lower-precedence children always get parentheses
   - Equal-precedence children on the right get parentheses (for non-commutative operators)
4. **LaTeX Formatting**:
   - Numbers: output value as-is
   - Addition: `left + right`
   - Subtraction: `left - right`
   - Multiplication: `left \times right`
   - Division: `left \div right`

**Example Transformation:**
- RPN Input: `5 3 + 2 *`
- AST: `BinaryOp(*, BinaryOp(+, Number(5), Number(3)), Number(2))`
- LaTeX: `$( 5 + 3 ) \times 2$`

The addition's result is wrapped in parentheses because `+` (precedence 1) is lower than `*` (precedence 2).

---

### Module 7: cli.py

**File**: `/Users/jfreeman/Coding/rpn2tex-rust-migration/projects/rpn2tex/source/cli.py`

#### Public API

**Functions:**
- `main() -> int`: Main entry point for CLI
  - Parses arguments
  - Reads input (file or stdin)
  - Tokenizes, parses, and generates LaTeX
  - Writes output (file or stdout)
  - Returns exit code (0 for success, 1 for error)

#### Dependencies
- Internal: `errors` (ErrorFormatter), `latex_gen` (LaTeXGenerator), `lexer` (Lexer, LexerError), `parser` (Parser, ParserError)
- External: `argparse`, `sys`, `pathlib` (Path)

#### Java Migration Notes

**Type Mappings:**
- `main() -> int` → Java `public static int main(String[] args)` or separate CLI class
- `sys.exit(code)` → Java `System.exit(code)`
- `sys.stdin.read()` → Java standard input reading
- `sys.stderr` → Java `System.err`
- `Path` → Java `java.nio.file.Path` or `java.io.File`
- `argparse.ArgumentParser` → Java argument parsing library (JCommander, picocli, or custom)

**Pattern Changes:**
- Python `argparse` → Java argument parsing:
  - Option 1: picocli library for modern CLI
  - Option 2: Apache Commons CLI
  - Option 3: Custom argument parsing
- Python context manager (`with open()`) → Java try-with-resources or explicit close
- Python exception handling → Java multi-catch or separate catch blocks
- Python `Path.read_text()` → Java `Files.readString()` or `new String(Files.readAllBytes())`
- Python `print(..., file=sys.stderr)` → Java `System.err.println()`

**Special Handling:**
- Exit codes: 0 for success, 1 for any error
- Input handling: Support stdin via "-" and file paths
- Error messages: Format errors using ErrorFormatter and output to stderr
- Output handling: Support stdout and file output
- File I/O exceptions: Handle FileNotFoundError, PermissionError, IsADirectoryError

#### Key Implementation Details

The CLI module orchestrates the entire pipeline:

1. **Argument Parsing**:
   - Required: `input` (file path or "-" for stdin)
   - Optional: `-o/--output` (output file, default stdout)

2. **Input Reading**:
   - If input == "-", read from stdin
   - Otherwise, read from file
   - Handle file not found, permission denied, is directory errors

3. **Processing Pipeline**:
   - Create ErrorFormatter with source text
   - Tokenize with Lexer
   - Parse with Parser
   - Generate LaTeX with LaTeXGenerator

4. **Error Handling**:
   - LexerError: Format with ErrorFormatter and output to stderr, exit 1
   - ParserError: Format with ErrorFormatter and output to stderr, exit 1
   - File I/O errors: Output appropriate error message and exit 1

5. **Output**:
   - If output file specified, write to file
   - Otherwise, write to stdout
   - Print status message to stderr (e.g., "Generated: output.tex")

---

## Migration Order (Dependency Analysis)

The following order respects dependencies and enables incremental testing:

### Phase 1: Foundation (No Dependencies)
1. **tokens.py** → Token.java, TokenType.java
   - No internal dependencies
   - Fundamental building block

2. **errors.py** → ErrorFormatter.java
   - No internal dependencies
   - Pure utility class

### Phase 2: AST Structures
3. **ast_nodes.py** → Expr.java, Number.java, BinaryOp.java
   - Depends on: None
   - Used by: Lexer, Parser, LaTeXGenerator

### Phase 3: Tokenization and Parsing
4. **lexer.py** → Lexer.java, LexerError.java
   - Depends on: tokens (Token, TokenType)
   - Used by: CLI

5. **parser.py** → Parser.java, ParserError.java
   - Depends on: tokens (Token, TokenType), ast_nodes (ASTNode, Number, BinaryOp, Expr)
   - Used by: CLI

### Phase 4: Code Generation
6. **latex_gen.py** → LaTeXGenerator.java
   - Depends on: ast_nodes (Number, BinaryOp, Expr)
   - Used by: CLI

### Phase 5: Integration
7. **cli.py** → Main.java
   - Depends on: All modules (Lexer, Parser, LaTeXGenerator, ErrorFormatter)
   - Entry point

---

## Quality Gates and Validation Criteria

### Module Validation Checklist

#### Token Module (tokens.py)
- [ ] TokenType enum defined with all 6 values
- [ ] Token class immutable with final fields
- [ ] Token(type, value, line, column) constructor works
- [ ] Token.toString() returns format matching Python __repr__
- [ ] Position information (line, column) preserved as 1-based integers
- [ ] All test cases in I/O contract work end-to-end

#### AST Module (ast_nodes.py)
- [ ] ASTNode base class with line and column attributes
- [ ] Number class extends ASTNode with value field
- [ ] BinaryOp class extends ASTNode with operator, left, right fields
- [ ] Expr type alias/interface properly handles Number and BinaryOp
- [ ] Immutability enforced with final fields
- [ ] Position information flows through AST construction

#### Error Module (errors.py)
- [ ] ErrorFormatter class constructs with source text
- [ ] format_error() returns formatted string with line context
- [ ] _get_context() correctly positions caret at error column
- [ ] Line numbers right-aligned in output
- [ ] Context display matches Python output exactly

#### Lexer Module (lexer.py)
- [ ] LexerError extends Exception with message, line, column fields
- [ ] Lexer(text) initializes with pos=0, line=1, column=1
- [ ] tokenize() returns list of tokens ending with EOF token
- [ ] Number tokens (integers and decimals) recognized correctly
- [ ] Operators (+, -, *, /) recognized correctly
- [ ] Negative numbers distinguished from subtraction operator
- [ ] Whitespace properly skipped
- [ ] Invalid characters raise LexerError with correct position
- [ ] Position tracking (line, column) accurate for multi-line input
- [ ] All lexer test cases from I/O contract pass

#### Parser Module (parser.py)
- [ ] ParserError extends Exception with message and token fields
- [ ] Parser(tokens) initializes with pos=0
- [ ] parse() returns Expr root of AST
- [ ] Number tokens create Number nodes
- [ ] Operators create BinaryOp nodes with correct operand order
- [ ] Stack validation: error on missing operands
- [ ] Stack validation: error on extra operands
- [ ] Stack validation: error on empty expression
- [ ] Operator precedence preserved in AST structure (left child on lower precedence = lower in tree)
- [ ] All parser test cases from I/O contract pass

#### LaTeX Module (latex_gen.py)
- [ ] LaTeXGenerator initialized without arguments
- [ ] generate() returns string wrapped in $...$ delimiters
- [ ] Number nodes output value as-is
- [ ] Addition operator outputs " + "
- [ ] Subtraction operator outputs " - "
- [ ] Multiplication operator outputs " \times " (with escaped backslash)
- [ ] Division operator outputs " \div " (with escaped backslash)
- [ ] Parentheses added for lower-precedence children
- [ ] Parentheses added for right-associative children with equal precedence
- [ ] No unnecessary parentheses added
- [ ] Floating-point numbers preserved as-is in output
- [ ] All LaTeX generation test cases from I/O contract pass

#### CLI Module (cli.py)
- [ ] main() returns int exit code
- [ ] Accepts input file path argument
- [ ] Accepts -o/--output optional argument
- [ ] Reads from stdin when input is "-"
- [ ] Reads from file when input is file path
- [ ] Handles FileNotFoundError
- [ ] Handles PermissionError
- [ ] Handles IsADirectoryError
- [ ] Lexer errors formatted and output to stderr
- [ ] Parser errors formatted and output to stderr
- [ ] LaTeX output written to stdout or file
- [ ] Status messages to stderr
- [ ] Returns 0 on success, 1 on error
- [ ] All integration test cases from I/O contract pass

### Integration Test Cases

All 21 test cases from the I/O contract must pass:

```
✓ 5 3 + → $5 + 3$
✓ 5 3 - → $5 - 3$
✓ 4 7 * → $4 \times 7$
✓ 10 2 / → $10 \div 2$
✓ 2 3 ^ → ERROR: Unexpected character '^'
✓ 5 3 + 2 * → $( 5 + 3 ) \times 2$
✓ 5 3 * 2 + → $5 \times 3 + 2$
✓ 10 2 / 5 * → $10 \div 2 \times 5$
✓ 5 3 - 2 - → $5 - 3 - 2$
✓ 100 10 / 5 / 2 / → $100 \div 10 \div 5 \div 2$
✓ 1 2 + 3 + 4 + → $1 + 2 + 3 + 4$
✓ 2 3 4 * + → $2 + 3 \times 4$
✓ 2 3 + 4 * → $( 2 + 3 ) \times 4$
✓ 2 3 4 + * → $2 \times ( 3 + 4 )$
✓ 2 3 * 4 + → $2 \times 3 + 4$
✓ 2 3 ^ 4 * → ERROR: Unexpected character '^'
✓ 2 3 4 ^ ^ → ERROR: Unexpected character '^'
✓ 3.14 2 * → $3.14 \times 2$
✓ 1.5 0.5 + → $1.5 + 0.5$
✓ 1 2 + 3 4 + * → $( 1 + 2 ) \times ( 3 + 4 )$
✓ 10 2 / 3 + 4 * → $( 10 \div 2 + 3 ) \times 4$
```

---

## Structural Design Decisions

### Package Structure

Recommended Java package structure:
```
src/main/java/com/rpn2tex/
├── Token.java
├── TokenType.java
├── Expr.java (interface or base class)
├── Number.java (implements Expr)
├── BinaryOp.java (implements Expr)
├── RpnException.java (base exception)
├── LexerError.java (extends RpnException)
├── ParserError.java (extends RpnException)
├── Lexer.java
├── Parser.java
├── LaTeXGenerator.java
├── ErrorFormatter.java
└── Main.java
```

### Exception Hierarchy

```
RpnException extends Exception
├── LexerError extends RpnException
└── ParserError extends RpnException
```

Create a base RpnException class for common error handling.

### Immutability Patterns

All data classes (Token, Number, BinaryOp, etc.) should be immutable:
- All fields `final`
- No setters
- Constructor initializes all fields
- Implement `equals()`, `hashCode()`, `toString()`
- Consider using `record` (Java 16+) or builder pattern if needed

### Visitor Pattern Implementation

For LaTeXGenerator, choose one approach:

**Option 1: Method Overloading (Recommended)**
```java
private String visit(Number node) { ... }
private String visit(BinaryOp node) { ... }
private String visit(Expr node) { // dispatcher
    if (node instanceof Number) return visit((Number) node);
    if (node instanceof BinaryOp) return visit((BinaryOp) node);
    throw new RuntimeException(...);
}
```

**Option 2: Sealed Interface (Java 17+)**
```java
sealed interface Expr permits Number, BinaryOp { }
// Use pattern matching in switch statements
```

**Option 3: Explicit Visitor Pattern**
```java
interface ExprVisitor<T> {
    T visitNumber(Number node);
    T visitBinaryOp(BinaryOp node);
}
```

### Type Conversion Strategies

**Expr Type Union:**
- Python: `Expr = Number | BinaryOp`
- Java: Either sealed interface or polymorphic reference
- Benefit: Type-safe representation of expression types

**Collections:**
- Python: `list[Token]` → Java: `List<Token>` (interface)
- Implementation: `ArrayList<Token>` or `LinkedList<Token>`
- Stack operations: Use `Deque<Expr>` for parser stack

---

## Key Migration Challenges

### 1. Python Union Types → Java Type Hierarchy
Challenge: Python uses `Expr = Number | BinaryOp` union syntax not available in Java
Solution: Implement as interface hierarchy or sealed abstract class

### 2. Singledispatch → Method Overloading
Challenge: Python's `@singledispatchmethod` decorator enables runtime type-based dispatch
Solution: Use Java method overloading or explicit `instanceof` checks

### 3. Position Tracking Precision
Challenge: Must maintain exact 1-based line/column tracking through all phases
Solution: Define clear invariant in Lexer; propagate through all token/node construction

### 4. LaTeX String Escaping
Challenge: Backslashes in LaTeX commands need escaping in Java strings
Solution: Use `"\\times"` and `"\\div"` for literal backslashes

### 5. Error Message Formatting
Challenge: Python's f-strings and string formatting need translation
Solution: Use `String.format()` or `StringBuilder` for dynamic strings

### 6. CLI Argument Parsing
Challenge: Python's argparse has no direct Java equivalent
Solution: Choose library (picocli, JCommander) or implement custom parser

### 7. File I/O and Streams
Challenge: Python's `Path` API and `sys.stdin/stderr` have different Java equivalents
Solution: Use `java.nio.file` and `System.in/out/err` with proper resource management

---

## Testing Strategy

### Unit Tests (by module)

1. **Token Tests**: Verify token creation, immutability, string representation
2. **AST Tests**: Verify node creation, immutability, type hierarchy
3. **Error Tests**: Verify error formatting with various line/column combinations
4. **Lexer Tests**: Verify tokenization for all token types, error cases
5. **Parser Tests**: Verify AST construction, operator precedence, error cases
6. **LaTeX Tests**: Verify output format, parenthesization logic
7. **CLI Tests**: Verify argument parsing, file I/O, error handling

### Integration Tests

Run all 21 test cases from I/O contract through entire pipeline:
- Input → Lexer → Parser → LaTeXGenerator → Output
- Verify output matches expected LaTeX exactly
- Verify error cases produce correct error messages

### Regression Tests

- Verify floating-point number preservation
- Verify left-associativity of - and / operators
- Verify that unnecessary parentheses are not added
- Verify error messages include correct line/column information

---

## Documentation and Comments

Each Java class should include:

1. **Class-level JavaDoc**: Purpose, usage example
2. **Method-level JavaDoc**: Parameters, return value, exceptions, examples
3. **Inline Comments**: Complex logic, non-obvious decisions
4. **Constants Documentation**: Explain magic numbers and mappings

Example format:
```java
/**
 * Tokenizes RPN input text into a stream of tokens.
 *
 * The lexer scans input character-by-character, producing tokens for
 * numbers, operators, and EOF. Whitespace serves as a delimiter.
 *
 * Example:
 * <pre>
 *     Lexer lexer = new Lexer("5 3 +");
 *     List<Token> tokens = lexer.tokenize();
 *     // tokens = [NUMBER(5), NUMBER(3), PLUS(+), EOF]
 * </pre>
 */
public class Lexer {
    // ...
}
```

---

## Summary

This migration specification provides comprehensive guidance for converting the Python rpn2tex implementation to Java. Key points:

1. **7 modules** to migrate in dependency order
2. **Immutable data structures** throughout
3. **Type-safe AST** representation
4. **Precise position tracking** (1-based line/column)
5. **Proper operator precedence** handling in LaTeX generation
6. **Comprehensive error handling** with context display
7. **21 test cases** for validation

The migration respects all behavioral requirements from the I/O contract while adapting to Java idioms and best practices.
